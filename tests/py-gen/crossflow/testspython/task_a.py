import logging
import multiprocessing
import time
from abc import abstractmethod
from typing import Dict

from crossflow.runtime import FailedJob, Task
from crossflow.testspython.python_tests_workflow_tasks import PythonTestsWorkflowTasks

from crossflow.testspython.type_a import TypeA
from crossflow.testspython.queue_a import QueueA

class TaskABase(Task):
    """NOTE: Auto-generated by Task2BaseClass on 2022-01-05T17:43:34.772882Z    
    Do not edit this class manually
    """
    
    task_enum: PythonTestsWorkflowTasks = PythonTestsWorkflowTasks.TASK_A

    def __init__(self):
        super().__init__()
                
        # Streams        

    @property
    def name(self) -> str:
        return self.__class__.task_enum.value

    def consume_queue_a_with_notifications(self, input_job: TypeA):        
        try:
            self.active_job = input_job
            job_id = input_job.job_id # keep in local scope for logging and error reporting
            
            # Delegate function to perform actual processing and confirmation messaging
            # def delegate():
            self.workflow.set_task_in_progress(self, input_job.job_id)
            self.consume_queue_a(self.active_job)
        # All other exceptions  
        except Exception as ex:
            try:
                self.workflow.report_internal_exception(ex)
                if self.active_job is not None:
                    self.active_job.failures += 1
                    self.workflow.failed_jobs_topic.send(FailedJob.from_exception(self.active_job, ex, self))
            except:
                self.workflow.report_internal_exception(ex)
    
        # Cleanup
        finally:
            try:
                self.workflow.set_task_waiting(self)
                self.active_job = None
                self._cancel_pending = False
                self._sent.update((k, False) for k in self._sent)                
            except Exception as ex:
                self.workflow.local_logger.exception("")
                self.workflow.report_internal_exception(ex)
    
    @abstractmethod
    def consume_queue_a(self, input_job: TypeA):
        pass
    
    def on_consume_queue_a_timeout(self, input_job: TypeA):
        return True
        
    def on_consume_queue_a_cancelled(self, input_job: TypeA):
        return True
        
    def close(self):
        pass



