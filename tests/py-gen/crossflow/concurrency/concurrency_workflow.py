import time

# Tasks
from concurrency.sleeper import Sleeper

# Types
from crossflow.concurrency import sleep_time
from crossflow.concurrency import result

# Streams
from crossflow.concurrency.sleep_times import SleepTimes

# Utility
from crossflow.concurrency.concurrency_workflow_tasks import ConcurrencyWorkflowTasks
from crossflow.runtime import BuiltinStream, Mode, LogLevel, Workflow, WorkflowConfig
from crossflow.serialization import Serializer, JsonSerializer


class ConcurrencyWorkflow(Workflow):
    """NOTE: Auto-generated by Workflow2Class on 2022-01-05T17:43:30.820254Z    
    Do not edit this class manually
    """

    def __init__(
        self,
        name="",
        instance=None,
        broker_host="localhost",
        stomp_port=61613,
        mode=Mode.WORKER,
        cache=None,
        cache_enabled=True,
        delete_cache=None,
        excluded_tasks=None,
        enable_prefetch=False,
        use_ssl=False,
        ssl_key=None,
        ssl_cert=None,
        ssl_ca_certs=None,
    ):
                 
        super().__init__(name=name,
                         instance=instance,
                         broker_host=broker_host,
                         stomp_port=stomp_port,
                         mode=mode,
                         cache=cache,
                         cache_enabled=cache_enabled,
                         delete_cache=delete_cache,
                         excluded_tasks=excluded_tasks,
                         enable_prefetch=enable_prefetch,
                         use_ssl=use_ssl,
                         ssl_key=ssl_key,
                         ssl_cert=ssl_cert,
                         ssl_ca_certs=ssl_ca_certs)
                         
        # Streams
        self.sleepTimes: SleepTimes = None
        self.results: BuiltinStream = None

        # Tasks
        self.sleeper = None
        if ConcurrencyWorkflowTasks.SLEEPER not in self._excluded_tasks:
            self.sleeper = Sleeper()
            self.sleeper.workflow = self
            self._tasks.append(self.sleeper)
        
    @classmethod
    def from_config(cls, config: WorkflowConfig):
        workflow = cls(
    		name=config.name,
            instance=config.instance,
            broker_host=config.broker_host,
            stomp_port=config.broker_port,
            mode=config.mode,
            use_ssl=config.use_ssl,
            ssl_key=config.ssl_key,
            ssl_cert=config.ssl_cert,
            ssl_ca_certs=config.ssl_ca_certs,
        )
        workflow.output_directory = config.output_directory
        return workflow

    def excluded_tasks(self, tasks=[]):
        assert isinstance(tasks, list)
        assert not tasks or [t for t in tasks if isinstance(t, ConcurrencyWorkflowTasks)]
        self._excluded_tasks = tasks

    def createWorker(self):
        worker = ConcurrencyWorkflow(Mode.WORKER)
        worker.instance(self._instance)
        return worker


    """
     * Run with initial delay in ms before starting execution (after creating broker
     * if master)
     * 
     * @param delay
    """
    def run(self, delay=0):
        """Run with an initial delay before starting execution

        :param delay: delay in ms before this worker will start running. Defaults to 0
        :type delay: int
        """
        self._delay=delay

        try:
            time.sleep(delay)
            self.connect()
            
            # Initialise Streams
            self.sleepTimes = SleepTimes(self, self._enable_prefetch)
            self._active_streams.append(self.sleepTimes)
            
            self.results = BuiltinStream("Results", self)
            self.results.init()
            self._active_streams.append(self.results)
            
            if (self.is_worker()):
                if not ConcurrencyWorkflowTasks.SLEEPER in self._excluded_tasks:
                        self.sleepTimes.add_consumer(self.sleeper, "Sleeper")
                        self.sleeper.results= self.results
        except Exception as ex:
            self.local_logger.exception("")
            self.report_internal_exception(ex)

    def getSleepTimes(self) -> SleepTimes:
        return self.sleepTimes
        
    def getResults(self) -> BuiltinStream:
        return self.results
        
    def getSleepTimeSource(self):
        return self.sleepTimeSource
        
    def getSleeper(self):
        return self.sleeper
        
    def _create_serializer(self) -> Serializer:
        return JsonSerializer()

    def _register_custom_serialization_types(self):
        self._serializer.register_type(sleep_time.SleepTime)
        self._serializer.register_type(result.Result)


if __name__ == '__main__':
    config = WorkflowConfig()
    app = ConcurrencyWorkflow.from_config(config)
    app.run()
    app.logger.log(LogLevel.INFO, "Finished Startup")
    while (not app.terminated):
        time.sleep(0.1)
    print("terminated")
    
