import logging
import multiprocessing
import time
from abc import abstractmethod
from typing import Dict

from crossflow.runtime import FailedJob, Task
from crossflow.concurrency.concurrency_workflow_tasks import ConcurrencyWorkflowTasks

from crossflow.concurrency.sleep_time import SleepTime
from crossflow.concurrency.result import Result
from crossflow.concurrency.sleep_times import SleepTimes
from crossflow.concurrency.results import Results

class SleeperBase(Task):
    """NOTE: Auto-generated by Task2BaseClass on 2022-01-05T17:43:30.820254Z    
    Do not edit this class manually
    """
    
    task_enum: ConcurrencyWorkflowTasks = ConcurrencyWorkflowTasks.SLEEPER

    def __init__(self):
        super().__init__()
                
        # Streams        
        self._results: Results = None

    @property
    def name(self) -> str:
        return self.__class__.task_enum.value

    @property
    def results(self) -> Results:
        return self._results
    
    @results.setter
    def results(self, stream: Results):
        self._results = stream
        self._sent["results"] = False

    def send_to_results(self, job: Result):
        self._pre_send(job)
        self.results.send(job, self.name)
        self._sent["results"] = True
    
    def _send_confirmation_to_results(self):
        if self._sent.get("results", False):
            conf = Result()
            conf.correlation_id = self.active_job.job_id
            conf.is_transaction_success_message = True
            conf.total_outputs = self.total_outputs
            self.results.send(conf, self.name)
        
    def consume_sleep_times_with_notifications(self, input_job: SleepTime):        
        try:
            self.active_job = input_job
            job_id = input_job.job_id # keep in local scope for logging and error reporting
            
            # Delegate function to perform actual processing and confirmation messaging
            # def delegate():
            self.workflow.set_task_in_progress(self, input_job.job_id)
            result = self.consume_sleep_times(self.active_job)
            if result is not None:
                result.transactional = False
                self.send_to_results(result)
        # All other exceptions  
        except Exception as ex:
            try:
                self.workflow.report_internal_exception(ex)
                if self.active_job is not None:
                    self.active_job.failures += 1
                    self.workflow.failed_jobs_topic.send(FailedJob.from_exception(self.active_job, ex, self))
            except:
                self.workflow.report_internal_exception(ex)
    
        # Cleanup
        finally:
            try:
                self.workflow.set_task_waiting(self)
                self.active_job = None
                self._cancel_pending = False
                self._sent.update((k, False) for k in self._sent)                
            except Exception as ex:
                self.workflow.local_logger.exception("")
                self.workflow.report_internal_exception(ex)
    
    @abstractmethod
    def consume_sleep_times(self, input_job: SleepTime):
        pass
    
    def on_consume_sleep_times_timeout(self, input_job: SleepTime):
        return True
        
    def on_consume_sleep_times_cancelled(self, input_job: SleepTime):
        return True
        
    def close(self):
        pass



